面试官：讲一下CAS
- CAS(Compare And Swap)，比较并交换。整个AQS同步组件，Atomic原子类操作等等都是基于CAS实现的，甚至ConcurrentHashMap在JDK1.8版本中，也调整为CAS+synchronized。可以说，CAS是整个JUC的基石。

- CAS的实现方式其实不难。在CAS中有三个参数：内存值V、旧的预期值A、要更新的值B，当且仅当内存值V的值等于旧的预期值A时，才会将内存值V的值修改为B，否则什么也不干，是一种乐观锁。

- 举了个AtomicInteger的例子，来给面试官阐述CAS的实现。
面试官：那CAS有什么缺陷吗？
- 我：CAS虽然高效的解决了原子问题，但是还是存在一些缺陷的，主要体现在三个方面： 
- 1.循环时间太长：
如果自旋CAS长时间不成功，则会给CPU带来非常大的开销，在JUC中，有些地方就会限制CAS自旋的次数。 
- 2.只能保证一个共享变量原子操作：
看了CAS的实现就知道这只能针对一个共享变量，如果是多个共享变量就只能使用锁了。或者把多个变量整成一个变量也可以用CAS。 
- 3.ABA问题：
CAS需要检查操作值有没有发生改变，如果没有发生改变则更新，但是存在这样一种情况：如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。对于ABA问题的解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加1，即A->B->A，变成1A->2B->3A。例如原子类中AtomicInteger会发生ABA问题，使用AtomicStampedReference可以解决ABA问题。


面试官：你能说下轻量级锁吗？
面试官：你先说下你对synchronized的了解。
面试官：什么是原子操作？
面试官：什么是Executors框架？
面试官：什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？
面试官：CycliBarriar和CountdownLatch有什么区别？
面试官：Java中用到的线程调度算法是什么？